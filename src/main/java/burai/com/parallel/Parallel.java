/*
 * Copyright (C) 2018 Satomichi Nishihara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package burai.com.parallel;

public class Parallel<E, R> {

    public static SumRule<Boolean> booleanAndRule() {
        return (b1, b2) -> {
            boolean b3 = false;
            b3 = b3 && (b1 == null ? false : b1);
            b3 = b3 && (b2 == null ? false : b2);
            return b3;
        };
    }

    public static SumRule<Boolean> booleanOrRule() {
        return (b1, b2) -> {
            boolean b3 = false;
            b3 = b3 || (b1 == null ? false : b1);
            b3 = b3 || (b2 == null ? false : b2);
            return b3;
        };
    }

    public static SumRule<Integer> integerSumRule() {
        return (i1, i2) -> {
            int i3 = 0;
            i3 += i1 == null ? 0 : i1;
            i3 += i2 == null ? 0 : i2;
            return i3;
        };
    }

    public static SumRule<Double> doubleSumRule() {
        return (d1, d2) -> {
            double d3 = 0.0;
            d3 += d1 == null ? 0.0 : d1;
            d3 += d2 == null ? 0.0 : d2;
            return d3;
        };
    }

    private int numThreads;

    private int threadCounter;

    private E[] elements;

    private R result;

    private SumRule<R> sumRule;

    public Parallel(E[] elements) {
        if (elements == null) {
            throw new IllegalArgumentException("elements is null.");
        }

        this.numThreads = 1;
        this.threadCounter = 0;
        this.elements = elements;
        this.result = null;
        this.sumRule = null;
    }

    public synchronized void setNumThreads(int numThreads) {
        this.numThreads = Math.max(1, numThreads);
    }

    public synchronized R getResult() {
        return this.result;
    }

    public synchronized void setSumRule(SumRule<R> sumRule) {
        this.sumRule = sumRule;
    }

    public synchronized R forEach(Performance<E, R> performance) {
        if (performance == null) {
            return null;
        }

        this.threadCounter = 0;
        int numThreads2 = this.numThreads;

        for (int iThread = 0; iThread < numThreads2; iThread++) {
            this.forEachKernel(iThread, numThreads2, performance);
        }

        while (this.threadCounter < numThreads2) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        return this.result;
    }

    private void forEachKernel(int iThread, int numThreads, Performance<E, R> performance) {
        Thread thread = new Thread(() -> {
            R result1 = null;
            for (int iElement = 0; iElement < this.elements.length; iElement++) {
                if ((iElement % numThreads) == iThread) {
                    E element = this.elements[iElement];
                    R result2 = performance.perform(element);
                    if (this.sumRule != null) {
                        result1 = this.sumRule.sum(result1, result2);
                    }
                }
            }

            synchronized (this) {
                this.threadCounter++;
                if (this.sumRule != null) {
                    this.result = this.sumRule.sum(this.result, result1);
                }

                this.notifyAll();
            }
        });

        thread.start();
    }
}
